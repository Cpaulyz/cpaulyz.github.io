<!doctype html><html lang=en-us><head><title>MIT6.824 Lab1 MapReduce | ChenYZ</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="A brief description of Hugo Shortcodes"><meta name=generator content="Hugo 0.64.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','your-google-analytics-id','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css integrity=sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js integrity=sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body);></script></head><body><nav class=navigation><a href=/><span class=arrow>←</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a class=button href=/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>MIT6.824 Lab1 MapReduce</h1><div class=tip><time datetime="2022-01-27 00:00:00 +0000 UTC">Jan 27, 2022</time>
<span class=split>·</span>
<span>wordCount</span>
<span class=split>·</span>
<span>13 minute read</span></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#0-简介>0 简介</a></li><li><a href=#1-环境搭建>1 环境搭建</a></li><li><a href=#2-结构分析>2 结构分析</a></li><li><a href=#3-实现>3 实现</a><ul><li><a href=#31-task分配>3.1 Task分配</a></li><li><a href=#32-map流程>3.2 Map流程</a></li><li><a href=#33-reduce流程>3.3 Reduce流程</a></li><li><a href=#34-跑起来>3.4 跑起来</a></li><li><a href=#35-错误容忍>3.5 错误容忍</a></li></ul></li><li><a href=#4-结果验证>4 结果验证</a></li></ul></nav></div></details></aside><div class=content><h1 id=lab1-mapreduce>Lab1 MapReduce</h1><h2 id=0-简介>0 简介</h2><p>Lab1实现了一个执行Wordcount任务的MapReduce，需要阅读论文<a href=https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf target=_blank rel=noopener>MapReduce</a></p><p>我在实现的过程中使用了go的chan和atomic替代显示的锁操作（Mutex），本文记录实现部分介绍我从零开始实现的过程，文中所附的部分代码并非最终版本，而是实现过程中的一些“快照”，完整代码可参考本人GitHub仓库：https://github.com/Cpaulyz/MIT6.824</p><p>不保证完全的 bug free，但经过100+次的测试均通过，测试脚本见“结果验证”章节的测试脚本。</p><p><p class=markdown-image><img src=https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211209000635805.png alt=image-20211209000635805></p></p><h2 id=1-环境搭建>1 环境搭建</h2><ul><li>实验环境：macOS Monterer (m1)</li><li>实验手册：2020版实验，http://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html</li></ul><p>直接 <code>brew install go</code> 即可，go version 为 go1.17.4 darwin/arm64</p><p>按照<a href=http://nil.csail.mit.edu/6.824/2020/labs/lab-mr.html target=_blank rel=noopener>实验手册</a>的指导，下载代码</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>$ git clone git://g.csail.mit.edu/6.824-golabs-2020 6.824
$ cd 6.824
$ cd src/main
$ go build -buildmode=plugin ../mrapps/wc.go
$ rm mr-out*
$ go run mrsequential.go wc.so pg*.txt
$ more mr-out-0
A 509
ABOUT 2
ACT 8
...
</code></pre></div><p>本人在 GoLand IDE 中进行开发，使用命令行运行</p><p><p class=markdown-image><img src=https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/image-20211207160528293.png alt=image-20211207160528293></p></p><p>为方便debug，写了一个shell脚本进行环境清理以及build</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080>#!bin/bash
</span><span style=color:#080></span><span style=color:#080;font-style:italic># build-wc.s</span>
rm -rf mr-*
go build -buildmode<span style=color:#666>=</span>plugin ../mrapps/wc.go
</code></pre></div><p>因为<code>test-mr.sh</code>脚本中有 timeout 指令，而macOS下没有而引发的 command not found 错误，可以参考：https://segmentfault.com/q/1010000011541227</p><h2 id=2-结构分析>2 结构分析</h2><p>本次实验只需要修改三个文件：<code>mr/worker.go</code>, <code>mr/master.go</code>, and <code>mr/rpc.go</code></p><ul><li>rpc：在该文件下定义rpc调用的请求体和返回题</li><li>master：实现master的功能，包括分配task、接受worker完成任务后的回调等</li><li>worker：根据给定的mapfunc和reducefunc，运行由 master 分配下来的 map task 和 reduce task，并通过 rpc 通知 master 任务是否完成</li></ul><p>其中，rpc部分一开始令我比较费解，在此进行记录：</p><p>实际上，实验代码已经为我们定义好了rpc框架，并给出了一个具体的Example，忽略框架性的代码，可以看到定义一个RPC的流程分为3步：</p><ol><li>在<code>rpc.go</code>中定义请求体和返回题</li><li>在被调用方实现Handler，根据请求参数计算返回值</li><li>在调用方（实验中均为worker）中调用框架给出的call，传入Handler、请求体、返回体即可</li></ol><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// master.go
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>Example</span>(args <span style=color:#666>*</span>ExampleArgs, reply <span style=color:#666>*</span>ExampleReply) <span style=color:#0b0;font-weight:700>error</span> {
	reply.Y = args.X <span style=color:#666>+</span> <span style=color:#666>1</span>
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
}

<span style=color:#080;font-style:italic>// rpc.go
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// the RPC argument and reply types are defined in rpc.go.
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> ExampleArgs <span style=color:#a2f;font-weight:700>struct</span> {
	X <span style=color:#0b0;font-weight:700>int</span>
}
<span style=color:#a2f;font-weight:700>type</span> ExampleReply <span style=color:#a2f;font-weight:700>struct</span> {
	Y <span style=color:#0b0;font-weight:700>int</span>
}

<span style=color:#080;font-style:italic>// worker.go
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>CallExample</span>() {
	<span style=color:#080;font-style:italic>// declare an argument structure.
</span><span style=color:#080;font-style:italic></span>	args <span style=color:#666>:=</span> ExampleArgs{}
	<span style=color:#080;font-style:italic>// fill in the argument(s).
</span><span style=color:#080;font-style:italic></span>	args.X = <span style=color:#666>99</span>
	<span style=color:#080;font-style:italic>// declare a reply structure.
</span><span style=color:#080;font-style:italic></span>	reply <span style=color:#666>:=</span> ExampleReply{}
	<span style=color:#080;font-style:italic>// send the RPC request, wait for the reply.
</span><span style=color:#080;font-style:italic></span>	<span style=color:#00a000>call</span>(<span style=color:#b44>&#34;Master.Example&#34;</span>, <span style=color:#666>&amp;</span>args, <span style=color:#666>&amp;</span>reply)
	<span style=color:#080;font-style:italic>// reply.Y should be 100.
</span><span style=color:#080;font-style:italic></span>	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;reply.Y %v\n&#34;</span>, reply.Y)
}
</code></pre></div><h2 id=3-实现>3 实现</h2><h3 id=31-task分配>3.1 Task分配</h3><p></p><p>根据hint我们可以得到一些启发——该实验可以从Task的分配入手</p><blockquote><p>One way to get started is to modify <code>mr/worker.go</code>'s <code>Worker()</code> to send an RPC to the master asking for a task. Then modify the master to respond with the file name of an as-yet-unstarted map task. Then modify the worker to read that file and call the application Map function, as in <code>mrsequential.go</code>.</p></blockquote><h4 id=311-master定义>3.1.1 Master定义</h4><p>参考论文中的“Master Data Structures”（The master keeps several data structures. For each map task and reduce task, it stores the state (idle, in-progress, or completed), and the identity of the worker machine (for non-idle tasks).），定义master结构体如下：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// mr/master.go
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> TaskStatus <span style=color:#0b0;font-weight:700>int8</span>

<span style=color:#a2f;font-weight:700>const</span> (
	IDLE      TaskStatus = <span style=color:#666>0</span>
	InProcess TaskStatus = <span style=color:#666>1</span>
	Completed TaskStatus = <span style=color:#666>2</span>
)

<span style=color:#a2f;font-weight:700>type</span> Master <span style=color:#a2f;font-weight:700>struct</span> {
	<span style=color:#080;font-style:italic>// Your definitions here.
</span><span style=color:#080;font-style:italic></span>	MapNum       <span style=color:#0b0;font-weight:700>int</span>
	ReduceNum    <span style=color:#0b0;font-weight:700>int</span>
	FileNames    []<span style=color:#0b0;font-weight:700>string</span>     <span style=color:#080;font-style:italic>// it has MapNum items
</span><span style=color:#080;font-style:italic></span>	MapStatus    []TaskStatus <span style=color:#080;font-style:italic>// it has MapNum items
</span><span style=color:#080;font-style:italic></span>	ReduceStatus []TaskStatus <span style=color:#080;font-style:italic>// it has ReduceNum items
</span><span style=color:#080;font-style:italic></span>	MapDone      <span style=color:#0b0;font-weight:700>bool</span>
	ReduceDone   <span style=color:#0b0;font-weight:700>bool</span>
	WorkerId     <span style=color:#0b0;font-weight:700>int32</span> 		  <span style=color:#080;font-style:italic>// allocate to worker
</span><span style=color:#080;font-style:italic></span>	MapWorker    []<span style=color:#0b0;font-weight:700>int</span>		  <span style=color:#080;font-style:italic>// it has MapNum items
</span><span style=color:#080;font-style:italic></span>	ReduceWorker []<span style=color:#0b0;font-weight:700>int</span> 		  <span style=color:#080;font-style:italic>// it has ReduceNum items
</span><span style=color:#080;font-style:italic></span>}
</code></pre></div><ul><li>我们以<code>MapId([0,MapNum))</code>和<code>ReduceId([0,ReduceNum])</code>来作为task的标识符，其中MapId对应第MapId个InputFIles</li><li><code>xxxxStatus</code>记录了map/reduce task的分配情况，<code>xxxxWorker</code>记录了map/reduce task的分配给了哪个worker</li><li><code>WorkerId</code>是一个不断自增的整数，用于WorkerId的分配</li><li><code>xxxxWorker</code>和<code>WorkerId</code>的存在原因将在错误恢复中用到，详看3.5</li></ul><h4 id=312-worker定义>3.1.2 Worker定义</h4><p>相应的，一个task可能为map，也可能为reduce，需要一个字段进行区分，定义的worker结构体如下</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// mr/worker.go
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> TaskType <span style=color:#0b0;font-weight:700>int8</span>

<span style=color:#a2f;font-weight:700>const</span> (
	MapTask    TaskType = <span style=color:#666>0</span>
	ReduceTask TaskType = <span style=color:#666>1</span>
)

<span style=color:#a2f;font-weight:700>type</span> WorkerTask <span style=color:#a2f;font-weight:700>struct</span> {
	WorkerId   <span style=color:#0b0;font-weight:700>int</span>
	Type       TaskType
	FileName   <span style=color:#0b0;font-weight:700>string</span>
	MapId      <span style=color:#0b0;font-weight:700>int</span>
	ReduceId   <span style=color:#0b0;font-weight:700>int</span>
	MapNum     <span style=color:#0b0;font-weight:700>int</span>
	ReduceNum  <span style=color:#0b0;font-weight:700>int</span>
	MapFunc    <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue
	ReduceFunc <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>
}
</code></pre></div><h4 id=313-rpc定义>3.1.3 RPC定义</h4><p>worker主动向master请求任务</p><blockquote><p>这里有一个细节，使用chan来代替锁结构，但需要注意因为chan缓冲的存在，在<code>generateTask</code>将task写入chan后需要立即将MapStatus/ReduceStatus改为InProcess，否则在下次循环时该task会被重复分配。</p></blockquote><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/rpc.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> NoArgs <span style=color:#a2f;font-weight:700>struct</span> {
}

<span style=color:#a2f;font-weight:700>type</span> AllocateTaskReply <span style=color:#a2f;font-weight:700>struct</span> {
	WorkerId  <span style=color:#0b0;font-weight:700>int</span>
	Type      TaskType
	FileName  <span style=color:#0b0;font-weight:700>string</span>
	MapId     <span style=color:#0b0;font-weight:700>int</span>
	ReduceId  <span style=color:#0b0;font-weight:700>int</span>
	MapNum    <span style=color:#0b0;font-weight:700>int</span>
	ReduceNum <span style=color:#0b0;font-weight:700>int</span>
}

<span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Worker</span>(mapf <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue,
	reducef <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#080;font-style:italic>// Your worker implementation here.
</span><span style=color:#080;font-style:italic></span>	task <span style=color:#666>:=</span> WorkerTask{MapFunc: mapf, ReduceFunc: reducef}
	task.<span style=color:#00a000>CallForAllocateTask</span>()
}

<span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>CallForAllocateTask</span>() {
	arg <span style=color:#666>:=</span> NoArgs{}
	reply <span style=color:#666>:=</span> AllocateTaskReply{}
	<span style=color:#00a000>call</span>(<span style=color:#b44>&#34;Master.AllocateTaskHandle&#34;</span>, <span style=color:#666>&amp;</span>arg, <span style=color:#666>&amp;</span>reply)
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;reply %v\n&#34;</span>, reply)
	task.WorkerId = reply.WorkerId
	task.Type = reply.Type
	task.ReduceNum = reply.ReduceNum
	task.MapNum = reply.MapNum
	<span style=color:#a2f;font-weight:700>if</span> task.Type <span style=color:#666>==</span> MapTask {
		task.FileName = reply.FileName
		task.MapId = reply.MapId
	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> task.Type <span style=color:#666>==</span> ReduceTask {
		task.ReduceId = reply.ReduceId
	}
}


<span style=color:#080;font-style:italic>// ====================== mr/master.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> mapAllocateId <span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>
<span style=color:#a2f;font-weight:700>var</span> reduceAllocateId <span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>

<span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>generateTask</span>() {
	<span style=color:#a2f;font-weight:700>for</span> !m.MapDone {
		<span style=color:#a2f;font-weight:700>for</span> i, _ <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> m.FileNames {
			<span style=color:#a2f;font-weight:700>if</span> m.MapStatus[i] <span style=color:#666>==</span> IDLE {
				m.MapStatus[mapIdx] = InProcess
				mapAllocateId <span style=color:#666>&lt;-</span> i
			}
		}
	}
	<span style=color:#a2f;font-weight:700>for</span> !m.ReduceDone {
		<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; m.ReduceNum; i<span style=color:#666>++</span> {
			<span style=color:#a2f;font-weight:700>if</span> m.ReduceStatus[i] <span style=color:#666>==</span> IDLE { 
				m.ReduceStatus[reduceIdx] = InProcess
				reduceAllocateId <span style=color:#666>&lt;-</span> i
			}
		}
	}
}

<span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>AllocateTaskHandle</span>(arg <span style=color:#666>*</span>NoArgs, reply <span style=color:#666>*</span>AllocateTaskReply) <span style=color:#0b0;font-weight:700>error</span> {
	<span style=color:#a2f;font-weight:700>select</span> {
	<span style=color:#a2f;font-weight:700>case</span> mapIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>mapAllocateId:
		reply.FileName = m.FileNames[mapIdx]
		reply.MapId = mapIdx
		reply.Type = MapTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.MapWorker[mapIdx] = reply.WorkerId
    <span style=color:#080;font-style:italic>// TODO：计时
</span><span style=color:#080;font-style:italic></span>		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	<span style=color:#a2f;font-weight:700>case</span> reduceIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>reduceAllocateId:
		reply.ReduceId = reduceIdx
		reply.Type = ReduceTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.ReduceWorker[reduceIdx] = reply.WorkerId
    <span style=color:#080;font-style:italic>// TODO：计时
</span><span style=color:#080;font-style:italic></span>		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
}

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>MakeMaster</span>(files []<span style=color:#0b0;font-weight:700>string</span>, nReduce <span style=color:#0b0;font-weight:700>int</span>) <span style=color:#666>*</span>Master {
	m <span style=color:#666>:=</span> Master{
		<span style=color:#a2f>len</span>(files),
		nReduce,
		files,
		<span style=color:#a2f>make</span>([]TaskStatus, <span style=color:#a2f>len</span>(files)),
		<span style=color:#a2f>make</span>([]TaskStatus, nReduce),
		<span style=color:#a2f;font-weight:700>false</span>,
		<span style=color:#a2f;font-weight:700>false</span>,
		<span style=color:#666>0</span>,
		<span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#a2f>len</span>(files)),
		<span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>int</span>, nReduce),
	}
	<span style=color:#a2f;font-weight:700>for</span> i, _ <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> files {
		m.MapStatus[i] = IDLE
	}
	fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;init master %v\n&#34;</span>, m)
	<span style=color:#080;font-style:italic>// Your code here.
</span><span style=color:#080;font-style:italic></span>	mapAllocateId = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>, m.MapNum)
	reduceAllocateId = <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>chan</span> <span style=color:#0b0;font-weight:700>int</span>, m.ReduceNum)
	<span style=color:#a2f;font-weight:700>go</span> m.<span style=color:#00a000>generateTask</span>()
	m.<span style=color:#00a000>server</span>()
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#666>&amp;</span>m
}
</code></pre></div><p>至此，我们尝试运行，手动起master和worker，应该可以看到worker被不断分配任务</p><p></p><p></p><p>但此时的<code>generateTask</code>方法仍有问题，注意到一旦所有的MapStatus都为InProcess时，mapDone仍然为false，此时会陷入死循环，这就需要我们在后续让worker运行被分配的mapTask，并在完成后回调给master，通知master修改状态。</p><h3 id=32-map流程>3.2 Map流程</h3><p></p><p>上文说道，worker被分配了map task，此时我们需要执行map task，并将中间结果写入local disks</p><p>实验手册中给出了几条有用的提示：</p><blockquote><ul><li><p>The worker should put intermediate Map output in files in the current directory, where your worker can later read them as input to Reduce tasks.</p></li><li><p>This lab relies on the workers sharing a file system. That&rsquo;s straightforward when all workers run on the same machine, but would require a global filesystem like GFS if the workers ran on different machines.</p></li><li><p>A reasonable naming convention for intermediate files is <code>mr-X-Y</code>, where X is the Map task number, and Y is the reduce task number.</p></li><li><p>The worker&rsquo;s map task code will need a way to store intermediate key/value pairs in files in a way that can be correctly read back during reduce tasks. One possibility is to use Go&rsquo;s encoding/json package. To write key/value pairs to a JSON file:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>  enc <span style=color:#666>:=</span> json.<span style=color:#00a000>NewEncoder</span>(file)
  <span style=color:#a2f;font-weight:700>for</span> _, kv <span style=color:#666>:=</span> <span style=color:#666>...</span> {
    err <span style=color:#666>:=</span> enc.<span style=color:#00a000>Encode</span>(<span style=color:#666>&amp;</span>kv)
</code></pre></div><p>and to read such a file back:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>  dec <span style=color:#666>:=</span> json.<span style=color:#00a000>NewDecoder</span>(file)
  <span style=color:#a2f;font-weight:700>for</span> {
    <span style=color:#a2f;font-weight:700>var</span> kv KeyValue
    <span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>:=</span> dec.<span style=color:#00a000>Decode</span>(<span style=color:#666>&amp;</span>kv); err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
      <span style=color:#a2f;font-weight:700>break</span>
    }
    kva = <span style=color:#a2f>append</span>(kva, kv)
  }
</code></pre></div></li><li><p>The map part of your worker can use the <code>ihash(key)</code> function (in <code>worker.go</code>) to pick the reduce task for a given key.</p></li></ul></blockquote><h4 id=321-worker执行>3.2.1 Worker执行</h4><p>worker拿到task后，根据Type字段区分task类型，如果是map task，则根据Map函数执行map流程</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Worker</span>(mapf <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue,
	reducef <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#080;font-style:italic>// Your worker implementation here.
</span><span style=color:#080;font-style:italic></span>	task <span style=color:#666>:=</span> WorkerTask{MapFunc: mapf, ReduceFunc: reducef}
	task.<span style=color:#00a000>CallForAllocateTask</span>()
	<span style=color:#a2f;font-weight:700>if</span> task.Type <span style=color:#666>==</span> MapTask {
		task.<span style=color:#00a000>DoMap</span>()
	}
}

<span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>DoMap</span>() {
   data, err <span style=color:#666>:=</span> ioutil.<span style=color:#00a000>ReadFile</span>(task.FileName)
   <span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
      fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file read err %s \n&#34;</span>, task.FileName)
      <span style=color:#a2f;font-weight:700>return</span>
   }
   kvs <span style=color:#666>:=</span> task.<span style=color:#00a000>MapFunc</span>(task.FileName, <span style=color:#a2f>string</span>(data))
   intermediate <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([][]KeyValue, task.ReduceNum)
   <span style=color:#a2f;font-weight:700>for</span> _, kv <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> kvs {
      idx <span style=color:#666>:=</span> <span style=color:#00a000>ihash</span>(kv.Key) <span style=color:#666>%</span> task.ReduceNum
      intermediate[idx] = <span style=color:#a2f>append</span>(intermediate[idx], kv)
   }
   <span style=color:#080;font-style:italic>// write to intermediate files
</span><span style=color:#080;font-style:italic></span>   <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; task.ReduceNum; i<span style=color:#666>++</span> {
      intermediateFileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;mr-%d-%d&#34;</span>, task.MapId, i)
      file, fileErr <span style=color:#666>:=</span> os.<span style=color:#00a000>Create</span>(intermediateFileName)
      <span style=color:#a2f;font-weight:700>if</span> fileErr <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
         fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file create error %s \n&#34;</span>, intermediateFileName)
         <span style=color:#a2f;font-weight:700>return</span>
      }
      <span style=color:#a2f;font-weight:700>defer</span> file.<span style=color:#00a000>Close</span>()
      enc <span style=color:#666>:=</span> json.<span style=color:#00a000>NewEncoder</span>(file)
      <span style=color:#a2f;font-weight:700>for</span> _, kv <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> intermediate[i] {
         encodeErr <span style=color:#666>:=</span> enc.<span style=color:#00a000>Encode</span>(kv)
         <span style=color:#a2f;font-weight:700>if</span> encodeErr <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
            fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;encode error %s \n&#34;</span>, intermediate[i])
            <span style=color:#a2f;font-weight:700>return</span>
         }
      }
   }
   task.<span style=color:#00a000>ReportWorkerTask</span>(<span style=color:#a2f;font-weight:700>nil</span>)
}
</code></pre></div><h4 id=322-rpc>3.2.2 RPC</h4><p>上文的最后，我们看到了一个doMap的最后调用了<code>task.ReportWorkerTask(nil)</code>，实际上这是通过RPC通知master该map task执行成功。注意，该函数也会在后续的reduce流程中被复用。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>ReportWorkerTask</span>(err <span style=color:#0b0;font-weight:700>error</span>) <span style=color:#0b0;font-weight:700>bool</span> {
	success <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>true</span>
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		success = <span style=color:#a2f;font-weight:700>false</span>
	}
	arg <span style=color:#666>:=</span> ReportTaskArgs{task.WorkerId, task.Type, task.MapId, task.ReduceId, success}
	reply <span style=color:#666>:=</span> ReportTaskReply{<span style=color:#a2f;font-weight:700>false</span>}
	<span style=color:#00a000>call</span>(<span style=color:#b44>&#34;Master.ReportWorkerTaskHandle&#34;</span>, <span style=color:#666>&amp;</span>arg, <span style=color:#666>&amp;</span>reply)
	<span style=color:#a2f;font-weight:700>return</span> reply.Success
}

<span style=color:#080;font-style:italic>// ====================== mr/rpc.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>type</span> ReportTaskReply <span style=color:#a2f;font-weight:700>struct</span> {
	Success  <span style=color:#0b0;font-weight:700>bool</span>
}

<span style=color:#a2f;font-weight:700>type</span> ReportTaskArgs <span style=color:#a2f;font-weight:700>struct</span> {
	WorkerId <span style=color:#0b0;font-weight:700>int</span>
	Type     TaskType
	MapId    <span style=color:#0b0;font-weight:700>int</span>
	ReduceId <span style=color:#0b0;font-weight:700>int</span>
	Success  <span style=color:#0b0;font-weight:700>bool</span>
}
</code></pre></div><h4 id=323-master被通知>3.2.3 Master被通知</h4><p>master处理worker完成task后通过PRC发来的通知，此时需要修改TaskStatus</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/master.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>ReportWorkerTaskHandle</span>(arg <span style=color:#666>*</span>ReportTaskArgs, reply <span style=color:#666>*</span>ReportTaskReply) <span style=color:#0b0;font-weight:700>error</span> {
	<span style=color:#a2f;font-weight:700>if</span> arg.Type <span style=color:#666>==</span> MapTask {
		<span style=color:#a2f;font-weight:700>if</span> arg.Success <span style=color:#666>&amp;&amp;</span> m.MapStatus[arg.MapId] <span style=color:#666>==</span> InProcess <span style=color:#666>&amp;&amp;</span> m.MapWorker[arg.MapId] <span style=color:#666>==</span> arg.WorkerId {
			fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;worker %d done \n&#34;</span>, arg.WorkerId)
			m.MapStatus[arg.MapId] = Completed
			isDone <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>true</span>
			<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; m.MapNum; i<span style=color:#666>++</span> {
				<span style=color:#a2f;font-weight:700>if</span> m.MapStatus[i] <span style=color:#666>!=</span> Completed {
					isDone = <span style=color:#a2f;font-weight:700>false</span>
					<span style=color:#a2f;font-weight:700>break</span>
				}
			}
			m.MapDone = isDone
			reply.Success = <span style=color:#a2f;font-weight:700>true</span>
		} <span style=color:#a2f;font-weight:700>else</span> { <span style=color:#080;font-style:italic>// failed
</span><span style=color:#080;font-style:italic></span>			m.MapStatus[arg.MapId] = IDLE
			reply.Success = <span style=color:#a2f;font-weight:700>false</span>
		}
	} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> arg.Type <span style=color:#666>==</span> ReduceTask {
		<span style=color:#a2f;font-weight:700>if</span> arg.Success <span style=color:#666>&amp;&amp;</span> m.ReduceStatus[arg.ReduceId] <span style=color:#666>==</span> InProcess <span style=color:#666>&amp;&amp;</span> m.ReduceWorker[arg.ReduceId] <span style=color:#666>==</span> arg.WorkerId {
			fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;worker %d done \n&#34;</span>, arg.WorkerId)
			m.ReduceStatus[arg.ReduceId] = Completed
			isDone <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>true</span>
			<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; m.ReduceNum; i<span style=color:#666>++</span> {
				<span style=color:#a2f;font-weight:700>if</span> m.ReduceStatus[i] <span style=color:#666>!=</span> Completed {
					isDone = <span style=color:#a2f;font-weight:700>false</span>
					<span style=color:#a2f;font-weight:700>break</span>
				}
			}
			m.ReduceDone = isDone
			reply.Success = <span style=color:#a2f;font-weight:700>true</span>
		} <span style=color:#a2f;font-weight:700>else</span> { <span style=color:#080;font-style:italic>// failed
</span><span style=color:#080;font-style:italic></span>			m.ReduceStatus[arg.ReduceId] = IDLE
			reply.Success = <span style=color:#a2f;font-weight:700>false</span>
		}
	}
	<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
}
</code></pre></div><p>至此，我们尝试运行，手动起master和worker，应该可以看到worker被不断分配任务，在完成map task后会被继续分配reduce task，并且我们能在main文件夹中看到中间文件的生成</p><p></p><h3 id=33-reduce流程>3.3 Reduce流程</h3><p></p><p>Reduce部分比较简单，和Map流程类似，我们只需要定义一个DoReduce的过程，并且在reduce完成后一样以RPC的方式通知master即可，最终输出的文件名称要按照实验手册中的严格给出</p><blockquote><ul><li>A <code>mr-out-X</code> file should contain one line per Reduce function output. The line should be generated with the Go <code>"%v %v"</code> format, called with the key and value. Have a look in <code>main/mrsequential.go</code> for the line commented &ldquo;this is the correct format&rdquo;. The test script will fail if your implementation deviates too much from this format.</li></ul></blockquote><h4 id=331-worker执行>3.3.1 Worker执行</h4><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Worker</span>(mapf <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue,
	reducef <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#080;font-style:italic>// Your worker implementation here.
</span><span style=color:#080;font-style:italic></span>	task <span style=color:#666>:=</span> WorkerTask{MapFunc: mapf, ReduceFunc: reducef}
	task.<span style=color:#00a000>CallForAllocateTask</span>()
	<span style=color:#a2f;font-weight:700>if</span> task.Type <span style=color:#666>==</span> MapTask {
		task.<span style=color:#00a000>DoMap</span>()
	} <span style=color:#a2f;font-weight:700>else</span> {
		task.<span style=color:#00a000>DoReduce</span>()
	}
}

<span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>DoReduce</span>() {
	kvsMap <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>][]<span style=color:#0b0;font-weight:700>string</span>)
	<span style=color:#080;font-style:italic>// read local disk to load intermediate file
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; task.MapNum; i<span style=color:#666>++</span> {
		fileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;mr-%d-%d&#34;</span>, i, task.ReduceId)
		file, err <span style=color:#666>:=</span> os.<span style=color:#00a000>Open</span>(fileName)
		<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file read err %s \n&#34;</span>, fileName)
			<span style=color:#a2f;font-weight:700>return</span>
		}
		dec <span style=color:#666>:=</span> json.<span style=color:#00a000>NewDecoder</span>(file)
		<span style=color:#a2f;font-weight:700>for</span> {
			<span style=color:#a2f;font-weight:700>var</span> kv KeyValue
			<span style=color:#a2f;font-weight:700>if</span> err = dec.<span style=color:#00a000>Decode</span>(<span style=color:#666>&amp;</span>kv); err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
				<span style=color:#a2f;font-weight:700>break</span>
			}
			_, ok <span style=color:#666>:=</span> kvsMap[kv.Key]
			<span style=color:#a2f;font-weight:700>if</span> !ok {
				kvsMap[kv.Key] = <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#666>0</span>)
			}
			kvsMap[kv.Key] = <span style=color:#a2f>append</span>(kvsMap[kv.Key], kv.Value)
		}
	}
	<span style=color:#080;font-style:italic>// reduce
</span><span style=color:#080;font-style:italic></span>	outFileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;mr-out-%d&#34;</span>, task.ReduceId)
	outFile, _ <span style=color:#666>:=</span> os.<span style=color:#00a000>Create</span>(outFileName)
	<span style=color:#a2f;font-weight:700>defer</span> outFile.<span style=color:#00a000>Close</span>()
	<span style=color:#a2f;font-weight:700>for</span> key, val <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> kvsMap {
		reduceRes <span style=color:#666>:=</span> task.<span style=color:#00a000>ReduceFunc</span>(key, val)
		fmt.<span style=color:#00a000>Fprintf</span>(outFile, <span style=color:#b44>&#34;%v %v\n&#34;</span>, key, reduceRes)
	}
	task.<span style=color:#00a000>ReportWorkerTask</span>(<span style=color:#a2f;font-weight:700>nil</span>)
}
</code></pre></div><p>至此，我们尝试运行，手动起master和worker，在完成reduce task后我们能在main文件夹中看到最终文件的生成</p><p></p><h3 id=34-跑起来>3.4 跑起来</h3><p>注意到，前面的实现里面，Worker是一次性的，而Master是一直存在的，这与论文里的情况明显不符合，也不是真实的运行情况，仅仅是方便实现的一种写法。</p><p>因此，在这里需要将其改为真实的情况，我们需要做的事情有：</p><ul><li>Master 一直分配任务<ul><li>当 MapTask 全部做完后，才可以分配 ReduceTask</li><li>当没有任务可以分配时，让 Worker 等待</li><li>当所有任务都做完时，让 Worker 退出</li></ul></li><li>Worker 轮询向 Master 请求任务，当所有任务做完后，Worker退出</li></ul><h4 id=341-worker-轮询>3.4.1 Worker 轮询</h4><p>在这里，我们需要引入除了Map和Reduce以外的另外两种Task，<code>WaitingTask</code>和<code>StopTask</code>，并修改worker主函数，使其成为可“复用”的worker，在一个循环中不断地进行拿任务—>做任务—>拿任务的循环。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>const</span> (
	MapTask     TaskType = <span style=color:#666>0</span>
	ReduceTask  TaskType = <span style=color:#666>1</span>
	WaitingTask TaskType = <span style=color:#666>2</span>
	StopTask    TaskType = <span style=color:#666>3</span>
)

<span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Worker</span>(mapf <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue,
	reducef <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#080;font-style:italic>// Your worker implementation here.
</span><span style=color:#080;font-style:italic></span>	os.<span style=color:#00a000>Mkdir</span>(<span style=color:#b44>&#34;tmp&#34;</span>, os.ModePerm)
	task <span style=color:#666>:=</span> WorkerTask{MapFunc: mapf, ReduceFunc: reducef}
	<span style=color:#a2f;font-weight:700>for</span> {
		task.<span style=color:#00a000>CallForAllocateTask</span>()
		<span style=color:#a2f;font-weight:700>switch</span> task.Type {
		<span style=color:#a2f;font-weight:700>case</span> MapTask:
			task.<span style=color:#00a000>DoMap</span>()
		<span style=color:#a2f;font-weight:700>case</span> ReduceTask:
			task.<span style=color:#00a000>DoReduce</span>()
		<span style=color:#a2f;font-weight:700>case</span> WaitingTask:
			time.<span style=color:#00a000>Sleep</span>(<span style=color:#666>1</span> <span style=color:#666>*</span> time.Second)
		<span style=color:#a2f;font-weight:700>case</span> StopTask:
			<span style=color:#a2f;font-weight:700>return</span>
		<span style=color:#a2f;font-weight:700>default</span>:
			<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;Invalid Task state received by worker&#34;</span>)
		}
	}
}
</code></pre></div><h4 id=341-master-分配>3.4.1 Master 分配</h4><p>因为引入了两种新的Task，所以Master在分配的时候也需要额外进行考虑，作出一下修改：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/master.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>AllocateTaskHandle</span>(arg <span style=color:#666>*</span>NoArgs, reply <span style=color:#666>*</span>AllocateTaskReply) <span style=color:#0b0;font-weight:700>error</span> {
	<span style=color:#a2f;font-weight:700>if</span> m.ReduceDone {
		reply.Type = StopTask
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
	<span style=color:#a2f;font-weight:700>select</span> {
	<span style=color:#a2f;font-weight:700>case</span> mapIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>mapAllocateId:
		reply.FileName = m.FileNames[mapIdx]
		reply.MapId = mapIdx
		reply.Type = MapTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.MapWorker[mapIdx] = reply.WorkerId
		<span style=color:#a2f;font-weight:700>go</span> m.<span style=color:#00a000>timerForWorker</span>(MapTask, mapIdx)
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	<span style=color:#a2f;font-weight:700>case</span> reduceIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>reduceAllocateId:
		reply.ReduceId = reduceIdx
		reply.Type = ReduceTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.ReduceWorker[reduceIdx] = reply.WorkerId
		<span style=color:#a2f;font-weight:700>go</span> m.<span style=color:#00a000>timerForWorker</span>(ReduceTask, reduceIdx)
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	<span style=color:#a2f;font-weight:700>default</span>:
		reply.Type = WaitingTask
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
}
</code></pre></div><p>最后需要给出Master退出的时间，根据实验手册，我们只需要在<code>Done()</code>方法中说明结束时机即可，也就是ReduceTask全部完成的时候。</p><blockquote><ul><li><code>main/mrmaster.go</code> expects <code>mr/master.go</code> to implement a <code>Done()</code> method that returns true when the MapReduce job is completely finished; at that point, <code>mrmaster.go</code> will exit.</li></ul></blockquote><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/master.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>//
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// main/mrmaster.go calls Done() periodically to find out
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// if the entire job has finished.
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>//
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>Done</span>() <span style=color:#0b0;font-weight:700>bool</span> {
	ret <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>false</span>
	<span style=color:#080;font-style:italic>// Your code here.
</span><span style=color:#080;font-style:italic></span>	ret = m.ReduceDone
	<span style=color:#a2f;font-weight:700>return</span> ret
}
</code></pre></div><p>至此，我们的MapReduce程序就可以跑起来了。你可以手动启动1个master和n个worker，完成wordcount。当然，也可以运行<code>test-mr.sh</code>进行检测，但是大概率会FAILED，因为我们目前实现的是理想化的版本，还没考虑worker节点宕机的情况。</p><h3 id=35-错误容忍>3.5 错误容忍</h3><h4 id=351-定时器>3.5.1 定时器</h4><p>在master分配任务的时候（<code>AllocateTaskHandle</code>），我们留了一个TODO，这里我们进行补充。</p><p>对于每一个Task，我们可以通过go route启动一个定时器来监控，如果超过一定的时间未完成，则将状态改为IDLE，重新进入到待分配的状态。</p><p>这里的时间我们根据实验手册假定为10s，超过10s即认为worker死亡</p><blockquote><p>For this lab, have the master wait for ten seconds; after that the master should assume the worker has died (of course, it might not have).</p></blockquote><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/master.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>AllocateTaskHandle</span>(arg <span style=color:#666>*</span>NoArgs, reply <span style=color:#666>*</span>AllocateTaskReply) <span style=color:#0b0;font-weight:700>error</span> {
	<span style=color:#a2f;font-weight:700>if</span> m.ReduceDone {
		reply.Type = StopTask
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
	<span style=color:#a2f;font-weight:700>select</span> {
	<span style=color:#a2f;font-weight:700>case</span> mapIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>mapAllocateId:
		reply.FileName = m.FileNames[mapIdx]
		reply.MapId = mapIdx
		reply.Type = MapTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.MapWorker[mapIdx] = reply.WorkerId
		<span style=color:#a2f;font-weight:700>go</span> m.<span style=color:#00a000>timerForWorker</span>(MapTask, mapIdx)
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	<span style=color:#a2f;font-weight:700>case</span> reduceIdx <span style=color:#666>:=</span> <span style=color:#666>&lt;-</span>reduceAllocateId:
		reply.ReduceId = reduceIdx
		reply.Type = ReduceTask
		reply.ReduceNum = m.ReduceNum
		reply.MapNum = m.MapNum
		reply.WorkerId = <span style=color:#a2f>int</span>(atomic.<span style=color:#00a000>AddInt32</span>(<span style=color:#666>&amp;</span>m.WorkerId, <span style=color:#666>1</span>))
		m.ReduceWorker[reduceIdx] = reply.WorkerId
		<span style=color:#a2f;font-weight:700>go</span> m.<span style=color:#00a000>timerForWorker</span>(ReduceTask, reduceIdx)
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	<span style=color:#a2f;font-weight:700>default</span>:
		reply.Type = WaitingTask
		<span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>nil</span>
	}
}

<span style=color:#a2f;font-weight:700>func</span> (m <span style=color:#666>*</span>Master) <span style=color:#00a000>timerForWorker</span>(taskType TaskType, idx <span style=color:#0b0;font-weight:700>int</span>) {
	ticker <span style=color:#666>:=</span> time.<span style=color:#00a000>NewTicker</span>(<span style=color:#666>10</span> <span style=color:#666>*</span> time.Second) <span style=color:#080;font-style:italic>// 10 second failed, according to the guide book
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>defer</span> ticker.<span style=color:#00a000>Stop</span>()
	<span style=color:#a2f;font-weight:700>for</span> {
		<span style=color:#a2f;font-weight:700>select</span> {
		<span style=color:#a2f;font-weight:700>case</span> <span style=color:#666>&lt;-</span>ticker.C:
			<span style=color:#a2f;font-weight:700>if</span> taskType <span style=color:#666>==</span> MapTask {
				m.MapStatus[idx] = IDLE
				<span style=color:#a2f;font-weight:700>return</span>
			} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> taskType <span style=color:#666>==</span> ReduceTask {
				m.ReduceStatus[idx] = IDLE
				<span style=color:#a2f;font-weight:700>return</span>
			}
		<span style=color:#a2f;font-weight:700>default</span>:
			<span style=color:#a2f;font-weight:700>if</span> taskType <span style=color:#666>==</span> MapTask {
				<span style=color:#a2f;font-weight:700>if</span> m.MapStatus[idx] <span style=color:#666>==</span> Completed {
					<span style=color:#a2f;font-weight:700>return</span>
				}
			} <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> taskType <span style=color:#666>==</span> ReduceTask {
				<span style=color:#a2f;font-weight:700>if</span> m.ReduceStatus[idx] <span style=color:#666>==</span> Completed {
					<span style=color:#a2f;font-weight:700>return</span>
				}
			}
		}
	}
}
</code></pre></div><h4 id=352-workerid>3.5.2 WorkerId</h4><p>我们为每个worker分配一个WorkerId，主要是用于错误恢复的情况。</p><p>我们考虑两种超时失效的情况</p><ol><li>worker挂掉，超时，worker直接死掉</li><li>worker出现一些问题，超时，过后worker恢复</li></ol><p>对于第一种情况，master在定时器超时后将task重新标记为IDLE，会重新将task分配给后续请求的worker执行。</p><p>对于第二种情况，master在先将task分配给worker A，A出现问题，定时器超时后将task重新标记为IDLE，重新将task分配给后续请求的worker B执行。此时如果A恢复正常，发回的report也会因为workerId不一致（<code>A!=B</code>）而不被master受理，避免影响。</p><p>事实上，该实验的test只考虑了第一种情况。</p><h4 id=352-临时文件>3.5.2 临时文件</h4><blockquote><ul><li>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use <code>ioutil.TempFile</code> to create a temporary file and <code>os.Rename</code> to atomically rename it.</li></ul></blockquote><p>同样是考虑先前超时失效的第二种情况，为了防止在异常情况下多个 worker 执行同一个任务时输出到同样的文件里面，一个小技巧是先输出到 temp 文件里，完成后再原子地重命名为最终文件。这个在 MapReduce 的论文和 lab1 的实验手册里面都有提到。</p><p>一个比较好的流程应该如下图所示，在任务完成阶段进行两次握手</p><blockquote><p>注：这里的第二次握手（report rename）目的是通知master文件已生成。以map task为例，如果没有这次握手，可能master会在rename成功前将reduce task分配给某个worker，此时执行reduce task的worker读不到正确的rename后文件，会出错。</p></blockquote><p><p class=markdown-image><img src=https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/mapreduce_tmpfile.png alt=mapreduce_tmpfile></p></p><p>但是在本次实验中，由于是share disk的结构，我们只需保证task在未结束前不产生“半成品”的文件即可，换言之，task任务结束可以直接将临时文件rename、再通知master，简化后的流程如下：</p><p><p class=markdown-image><img src=https://cyzblog.oss-cn-beijing.aliyuncs.com/macimg/mapreduce_tmpfile_simple.png alt=mapreduce_tmpfile_simple></p></p><p>实现时需要在worker初始化时候确保temp目录的创建</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>var</span> tmpDir <span style=color:#0b0;font-weight:700>string</span> = <span style=color:#b44>&#34;tmp/&#34;</span>

<span style=color:#080;font-style:italic>//
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>// main/mrworker.go calls this function.
</span><span style=color:#080;font-style:italic></span><span style=color:#080;font-style:italic>//
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>Worker</span>(mapf <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#0b0;font-weight:700>string</span>) []KeyValue,
	reducef <span style=color:#a2f;font-weight:700>func</span>(<span style=color:#0b0;font-weight:700>string</span>, []<span style=color:#0b0;font-weight:700>string</span>) <span style=color:#0b0;font-weight:700>string</span>) {
	<span style=color:#080;font-style:italic>// Your worker implementation here.
</span><span style=color:#080;font-style:italic></span>	os.<span style=color:#00a000>Mkdir</span>(<span style=color:#b44>&#34;tmp&#34;</span>, os.ModePerm)
	task <span style=color:#666>:=</span> WorkerTask{MapFunc: mapf, ReduceFunc: reducef}
	<span style=color:#a2f;font-weight:700>for</span> {
		task.<span style=color:#00a000>CallForAllocateTask</span>()
		<span style=color:#a2f;font-weight:700>switch</span> task.Type {
		<span style=color:#a2f;font-weight:700>case</span> MapTask:
			task.<span style=color:#00a000>DoMap</span>()
		<span style=color:#a2f;font-weight:700>case</span> ReduceTask:
			task.<span style=color:#00a000>DoReduce</span>()
		<span style=color:#a2f;font-weight:700>case</span> WaitingTask:
			time.<span style=color:#00a000>Sleep</span>(<span style=color:#666>1</span> <span style=color:#666>*</span> time.Second)
		<span style=color:#a2f;font-weight:700>case</span> StopTask:
			<span style=color:#a2f;font-weight:700>return</span>
		<span style=color:#a2f;font-weight:700>default</span>:
			<span style=color:#a2f>panic</span>(<span style=color:#b44>&#34;Invalid Task state received by worker&#34;</span>)
		}
	}
}
</code></pre></div><p>修改doMap和doReduce方法，先写入临时文件，后统一进行rename</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#080;font-style:italic>// ====================== mr/worker.go ====================== 
</span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>DoMap</span>() {
	data, err <span style=color:#666>:=</span> ioutil.<span style=color:#00a000>ReadFile</span>(task.FileName)
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file read err %s \n&#34;</span>, task.FileName)
		<span style=color:#a2f;font-weight:700>return</span>
	}
	kvs <span style=color:#666>:=</span> task.<span style=color:#00a000>MapFunc</span>(task.FileName, <span style=color:#a2f>string</span>(data))
	intermediate <span style=color:#666>:=</span> <span style=color:#a2f>make</span>([][]KeyValue, task.ReduceNum)
	<span style=color:#a2f;font-weight:700>for</span> _, kv <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> kvs {
		idx <span style=color:#666>:=</span> <span style=color:#00a000>ihash</span>(kv.Key) <span style=color:#666>%</span> task.ReduceNum
		intermediate[idx] = <span style=color:#a2f>append</span>(intermediate[idx], kv)
	}
	<span style=color:#080;font-style:italic>// write to temp intermediate files
</span><span style=color:#080;font-style:italic></span>	prefix <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;map%d&#34;</span>, task.WorkerId)
	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; task.ReduceNum; i<span style=color:#666>++</span> {
		intermediateFileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;%s.mr-%d-%d.*&#34;</span>,prefix,task.MapId, i)
		file, fileErr <span style=color:#666>:=</span> ioutil.<span style=color:#00a000>TempFile</span>(tmpDir,intermediateFileName)
		<span style=color:#a2f;font-weight:700>if</span> fileErr <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file create error %s,%s \n&#34;</span>, intermediateFileName,fileErr)
			<span style=color:#a2f;font-weight:700>return</span>
		}
		<span style=color:#a2f;font-weight:700>defer</span> file.<span style=color:#00a000>Close</span>()
		enc <span style=color:#666>:=</span> json.<span style=color:#00a000>NewEncoder</span>(file)
		<span style=color:#a2f;font-weight:700>for</span> _, kv <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> intermediate[i] {
			encodeErr <span style=color:#666>:=</span> enc.<span style=color:#00a000>Encode</span>(kv)
			<span style=color:#a2f;font-weight:700>if</span> encodeErr <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
				fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;encode error %s \n&#34;</span>, intermediate[i])
				<span style=color:#a2f;font-weight:700>return</span>
			}
		}
	}
	task.<span style=color:#00a000>RenameTempFile</span>(prefix)
	success <span style=color:#666>:=</span> task.<span style=color:#00a000>ReportWorkerTask</span>(<span style=color:#a2f;font-weight:700>nil</span>)
	<span style=color:#a2f;font-weight:700>if</span> success{
		<span style=color:#080;font-style:italic>// 简化后，nothing to do
</span><span style=color:#080;font-style:italic></span>	}
}

<span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>DoReduce</span>() {
	kvsMap <span style=color:#666>:=</span> <span style=color:#a2f>make</span>(<span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>][]<span style=color:#0b0;font-weight:700>string</span>)
	<span style=color:#080;font-style:italic>// read local disk to load intermediate file
</span><span style=color:#080;font-style:italic></span>	<span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#666>0</span>; i &lt; task.MapNum; i<span style=color:#666>++</span> {
		fileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;mr-%d-%d&#34;</span>, i, task.ReduceId)
		file, err <span style=color:#666>:=</span> os.<span style=color:#00a000>Open</span>(fileName)
		<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
			fmt.<span style=color:#00a000>Printf</span>(<span style=color:#b44>&#34;file read err %s \n&#34;</span>, fileName)
			<span style=color:#a2f;font-weight:700>return</span>
		}
		dec <span style=color:#666>:=</span> json.<span style=color:#00a000>NewDecoder</span>(file)
		<span style=color:#a2f;font-weight:700>for</span> {
			<span style=color:#a2f;font-weight:700>var</span> kv KeyValue
			<span style=color:#a2f;font-weight:700>if</span> err = dec.<span style=color:#00a000>Decode</span>(<span style=color:#666>&amp;</span>kv); err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
				<span style=color:#a2f;font-weight:700>break</span>
			}
			_, ok <span style=color:#666>:=</span> kvsMap[kv.Key]
			<span style=color:#a2f;font-weight:700>if</span> !ok {
				kvsMap[kv.Key] = <span style=color:#a2f>make</span>([]<span style=color:#0b0;font-weight:700>string</span>, <span style=color:#666>0</span>)
			}
			kvsMap[kv.Key] = <span style=color:#a2f>append</span>(kvsMap[kv.Key], kv.Value)
		}
	}
	<span style=color:#080;font-style:italic>// reduce to tmp file
</span><span style=color:#080;font-style:italic></span>	prefix <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;reduce%d&#34;</span>, task.WorkerId)
	outFileName <span style=color:#666>:=</span> fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;%s.mr-out-%d.*&#34;</span>, prefix,task.ReduceId)
	outFile, _ <span style=color:#666>:=</span>ioutil.<span style=color:#00a000>TempFile</span>(tmpDir,outFileName)
	<span style=color:#a2f;font-weight:700>defer</span> outFile.<span style=color:#00a000>Close</span>()
	<span style=color:#a2f;font-weight:700>for</span> key, val <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> kvsMap {
		reduceRes <span style=color:#666>:=</span> task.<span style=color:#00a000>ReduceFunc</span>(key, val)
		fmt.<span style=color:#00a000>Fprintf</span>(outFile, <span style=color:#b44>&#34;%v %v\n&#34;</span>, key, reduceRes)
	}
	task.<span style=color:#00a000>RenameTempFile</span>(prefix)
	success <span style=color:#666>:=</span> task.<span style=color:#00a000>ReportWorkerTask</span>(<span style=color:#a2f;font-weight:700>nil</span>)
	<span style=color:#a2f;font-weight:700>if</span> success{
		<span style=color:#080;font-style:italic>// 简化后，nothing to do
</span><span style=color:#080;font-style:italic></span>	}
}

<span style=color:#a2f;font-weight:700>func</span> (task <span style=color:#666>*</span>WorkerTask) <span style=color:#00a000>RenameTempFile</span>(prefix <span style=color:#0b0;font-weight:700>string</span>)  {
	<span style=color:#080;font-style:italic>// rename file
</span><span style=color:#080;font-style:italic></span>	files, err <span style=color:#666>:=</span> ioutil.<span style=color:#00a000>ReadDir</span>(tmpDir)
	<span style=color:#a2f;font-weight:700>if</span> err <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> {
		fmt.<span style=color:#00a000>Println</span>(<span style=color:#b44>&#34;read temp dir error&#34;</span>)
	}
	<span style=color:#a2f;font-weight:700>for</span> _,info <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> files{
		<span style=color:#a2f;font-weight:700>if</span> strings.<span style=color:#00a000>HasPrefix</span>(info.<span style=color:#00a000>Name</span>(),prefix){
			intermediateFileName <span style=color:#666>:=</span> strings.<span style=color:#00a000>Split</span>(info.<span style=color:#00a000>Name</span>(),<span style=color:#b44>&#34;.&#34;</span>)[<span style=color:#666>1</span>]
			os.<span style=color:#00a000>Rename</span>(tmpDir<span style=color:#666>+</span>info.<span style=color:#00a000>Name</span>(),intermediateFileName)
		}
	}
}
</code></pre></div><h2 id=4-结果验证>4 结果验证</h2><p>一次通过<code>test-mr.sh</code>并不能保证正确性，因此我在main目录下新建<code>test-mr-loop.sh</code>脚本，循环运行<code>test-mr.sh</code>进行测试</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#080>#!/bin/sh
</span><span style=color:#080></span><span style=color:#b8860b>str2</span><span style=color:#666>=</span><span style=color:#b44>&#34;PASSED&#34;</span>
<span style=color:#a2f>read</span> -p <span style=color:#b44>&#34;Enter loop times&gt;&#34;</span> loop_time
<span style=color:#b8860b>i</span><span style=color:#666>=</span><span style=color:#666>0</span>
<span style=color:#b8860b>success</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
<span style=color:#b8860b>pass</span><span style=color:#666>=</span><span style=color:#b44>&#34;PASSED ALL TESTS&#34;</span>

<span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>[</span> <span style=color:#b8860b>$i</span> -lt <span style=color:#b8860b>$loop_time</span> <span style=color:#666>]</span>
<span style=color:#a2f;font-weight:700>do</span>
  <span style=color:#a2f>let</span> <span style=color:#b44>&#39;i++&#39;</span>
  sh test-mr.sh &gt; test.log
  <span style=color:#b8860b>result</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>tail -n <span style=color:#666>1</span> test.log|awk <span style=color:#b44>&#39;{print substr($0,length($0)-16)}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
  <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>[</span><span style=color:#666>[</span> <span style=color:#b8860b>$result</span> <span style=color:#666>=</span>~ <span style=color:#b8860b>$str2</span> <span style=color:#666>]</span><span style=color:#666>]</span>;<span style=color:#a2f;font-weight:700>then</span>
    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;PASSED TEST TIMES:&#34;</span><span style=color:#b8860b>$i</span>
  <span style=color:#a2f;font-weight:700>else</span>
    <span style=color:#b8860b>success</span><span style=color:#666>=</span><span style=color:#a2f>false</span>
    <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;FAIL AT&#34;</span> <span style=color:#b8860b>$i</span> <span style=color:#b44>&#34;TIMES&#34;</span>
    <span style=color:#a2f>break</span>
  <span style=color:#a2f;font-weight:700>fi</span>
<span style=color:#a2f;font-weight:700>done</span>


<span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span><span style=color:#b8860b>$success</span><span style=color:#666>)</span>
<span style=color:#a2f;font-weight:700>then</span>
  <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;PASS ALL TEST&#34;</span> <span style=color:#b8860b>$loop_time</span> <span style=color:#b44>&#34;TIMES&#34;</span>
<span style=color:#a2f;font-weight:700>fi</span>
</code></pre></div><p></p></div><div class=tags><a href=tags/mit6.824>MIT6.824</a>
<a href=tags/distributed-system>distributed system</a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/Cpaulyz rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64C68.418278 72 72 68.418278 72 64V8c0-4.418278-3.581721999999999-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64C541083001e-24 68.418278 3.581722 72 8 72z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644 12 47.7406712 18.876 56.7718301 28.4145 59.9584121 29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482 23.343 56.1558981 21.9345 51.4693938 21.9345 51.4693938 20.844 48.6864054 19.2705 47.9454799 19.2705 47.9454799 17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943 21.843 46.6503662 23.1105 48.9634994 23.1105 48.9634994 25.2525 52.6455377 28.728 51.5823398 30.096 50.9649018 30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671 20.688 33.2052792 21.6225 31.0547881 23.1585 29.3696344 22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585 23.3925 22.9934585 25.4085 22.3459017 29.9925 25.4632101 31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101 46.5915 22.3459017 48.603 22.9934585 48.603 22.9934585 49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671 51.309 45.0917119 45.6975 47.1292571 40.3515 47.7256117 41.2125 48.4695491 41.9805 49.9393525 41.9805 52.1877301 41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a></div><div class=copyright>© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>cpaulyz</div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-cactus-plus>nodejh</a></div></footer></body></html>